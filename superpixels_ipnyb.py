# -*- coding: utf-8 -*-
"""Superpixels.ipnyb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qUIZVszt2xfEU2wDGFsGDWfKoB2sYY0W

# Assignment 1
<!-- Understanding and implementing SLIC Superpixels. -->
A superpixel can be defined as a group of pixels that share common characteristics. Simple Linear Iterative Clustering (SLIC) generates superpixels by clustering pixels based on their color similarity and proximity in the image plane. The purpose of this assignment is to understand and implement SLIC Superpixels.

Some pointers before we start:
- Please follow all submission guidlines which are posted on piazza.
- Ensure all outputs are displayed while rendering the PDF.
- Only modify the code blocks  which has a "TODO".
- Below you can see some outputs for an image of a cow. These images represent the kind of output that is expected. 
- Feel free to reach out to any of the TAs for any doubts/issues.
"""

# from google.colab import drive
# drive.mount('/content/drive')

"""Let's download the dataset first."""


"""We only focus on six images in this assignment."""

im_list = ['MSRC_ObjCategImageDatabase_v1/1_22_s.bmp',
           'MSRC_ObjCategImageDatabase_v1/1_27_s.bmp',
           'MSRC_ObjCategImageDatabase_v1/3_3_s.bmp',
           'MSRC_ObjCategImageDatabase_v1/3_6_s.bmp',
           'MSRC_ObjCategImageDatabase_v1/6_5_s.bmp',
           'MSRC_ObjCategImageDatabase_v1/7_19_s.bmp']

# Commented out IPython magic to ensure Python compatibility.
#All important functions to plot, do not modify this block
# %matplotlib inline
import cv2
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.patches as mpatches

def plot_image(im,title,xticks=[],yticks= [],isCv2 = True):
    """
    im :Image to plot
    title : Title of image 
    xticks : List of tick values. Defaults to nothing
    yticks :List of tick values. Defaults to nothing 
    cv2 :Is the image cv2 image? cv2 images are BGR instead of RGB. Default True
    """
    plt.figure()
    if isCv2:
        im = im[:,:,::-1]
    plt.imshow(im)
    plt.title(title)
    plt.xticks(xticks)
    plt.yticks(yticks)

def superpixel_plot(im,seg,title = "Superpixels"):
    """
    Given an image (nXmX3) and pixelwise class mat (nXm), 
    1. Consider each class as a superpixel
    2. Calculate mean superpixel value for each class
    3. Replace the RGB value of each pixel in a class with the mean value  
    
    Inputs:
    im: Input image
    seg: Segmentation map
    title: Title of the plot 
    
    Output: None
    Creates a plot    
    """
    clust = np.unique(seg)
    mapper_dict = {i: im[seg == i].mean(axis = 0)/255. for i in clust}

    seg_img =  np.zeros((seg.shape[0],seg.shape[1],3))
    for i in clust:
        seg_img[seg == i] = mapper_dict[i]
    
    plot_image(seg_img,title)
    
    return    

def rgb_segment(seg,n = None,plot = True,title=None,legend = True,color = None):
    """
    Given a segmentation map, get the plot of the classes
    """
    clust = np.unique(seg)
    if n is None:
        n = len(clust)
    if color is None:
        cm = plt.cm.get_cmap('hsv',n+1)
        # mapper_dict = {i:np.array(cm(i/n)) for i in clust}
        mapper_dict = {i:np.random.rand(3,) for i in clust} 
    #elif color == 'mean':
        #TODO..get the mean color of cluster center and assign that to mapper_dict

    seg_img =  np.zeros((seg.shape[0],seg.shape[1],3))
    for i in clust:
        seg_img[seg == i] = mapper_dict[i][:3]

    if plot: 
        plot_image(seg_img,title = title)
    if legend:
        # get the colors of the values, according to the 
        # colormap used by imshow
        patches = [ mpatches.Patch(color=mapper_dict[i], label=" : {l}".format(l=i) ) for i in range(n) ]
        # put those patched as legend-handles into the legend
        plt.legend(handles=patches, bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0. )
        plt.grid(True)
        plt.show()

    return seg_img

"""Let's see what the six images are:"""

# for i in im_list:
    # plot_image(cv2.imread(i),i.split("/")[-1])

"""Get image and visualize it. Its a scenery with 3 elements. You can see the segmentation ground truth in the GT bitmap."""

im = cv2.imread(im_list[0])
seg = cv2.imread(im_list[0].replace("_s","_s_GT"))

# plot_image(im,"Image")
# plot_image(seg,"Segmentation")


"""###Question 3: SLIC

It doesn't look like we have a very favourable outcome with superpixels simply being implemented as K-means. Can we do better? Have a look at the SLIC paper [here](https://www.iro.umontreal.ca/~mignotte/IFT6150/Articles/SLIC_Superpixels.pdf). Incorporate S and m and redefine your distance metric as per the paper.
"""

import cv2
import tqdm
from scipy.spatial import distance_matrix
#TODO
############Algorithm############
#Compute grid steps: S
#you can explore different values of m
#initialize cluster centers [l,a,b,x,y] using  
#Perturb for minimum G
#while not converged
##for every pixel:
####  compare distance D_s with each cluster center within 2S X 2S. 
####  Assign to nearest cluster
##calculate new cluster center 
 

def SLIC(im, k):
    """
    Input arguments: 
    im: image input
    k: number of cluster segments


    Compute
    S: As described in the paper
    m: As described in the paper (use the same value as in the paper)
    follow the algorithm..
    
    returns:
    segmap: 2D matrix where each value corresponds to the image pixel's cluster number
    """
    def isValidIndex(i,j,mat):
       return i>=0 and i<mat.shape[0] and j>=0 and j<mat.shape[1]
    
    imLab =  cv2.cvtColor(im, cv2.COLOR_BGR2LAB)    
    r,c,d = im.shape
        
    x,y = np.mgrid[0:r,0:c]
    pixels_xy = np.column_stack((x.ravel(),y.ravel()))
    pixels_rgb = imLab.reshape((r*c),d)
    labels = None

    N = imLab.shape[0]*imLab.shape[1]                                             #Compute grid steps: S
    S = int((N/k)**0.5)
    m = 35


    x,y = np.mgrid[0:r-S:S,0:c-S:S] 


    c_xy  = np.column_stack((x.ravel(),y.ravel()))                                 #initialize cluster centers
    c_rgb = imLab[c_xy[:,0],c_xy[:,1]]
   

    sobelx = cv2.Sobel(imLab,cv2.CV_64F,1,0,ksize=5)                               #Perturb for minimum G
    sobely = cv2.Sobel(imLab,cv2.CV_64F,0,1,ksize=5)
    G = np.linalg.norm(sobelx,axis = 2)**2 + np.linalg.norm(sobely,axis=2)**2     
    # for i in range(len(c_xy)):
       # x,y = c_xy[i]
       # region = G[max(x - 1,0):x+1,max(y-1,0):y+1]

       # min_x,min_y  = np.where(region == np.min(region))
       # perturb_x,perturb_y = min_x[0],min_y[0]
       
       # c_xy[i] = [max(x-1,0)+perturb_x, max(y-1,0)+perturb_y]



    numClusters = len(c_xy)
    maxIterations = 4
    for i in tqdm.tqdm(range(maxIterations)):
        labels = []
        for j in range(r):
            for k in range(c):

                pixel_xy = np.array([j,k])
                pixel_rgb =  imLab[j,k] 
                
                ind = np.where(np.linalg.norm((c_xy - pixel_xy),axis=1)<= 2*S)[0]

                local_c_xy  = c_xy[ind]
                local_c_rgb = c_rgb[ind] 
                
                rgbPointDist = distance_matrix(pixel_rgb.reshape(1,-1),local_c_rgb)[0]
                xyPointDist =  distance_matrix(pixel_xy.reshape(1,-1),local_c_xy)[0]

                local_clusterPointDist = rgbPointDist + (m/S)*xyPointDist  
                labels.append(ind[np.argmin(local_clusterPointDist)])
        
        labels = np.array(labels)
        c_rgb = np.array([np.mean(pixels_rgb[labels == q],axis = 0) for q in range(numClusters)])      
        c_xy  = np.array([np.mean(pixels_xy[labels == q],axis = 0) for q in range(numClusters)])       
    
    
    ####Connectivity
    clusterXY = np.expand_dims(c_xy,axis=0)
    cluster = clusterXY.reshape(x.shape[0],x.shape[1],2)

    label_id = 0;
    for i in range(cluster.shape[0]):
        for j in range(cluster.shape[1]):
            
            ind = np.where(labels == label_id)[0]      #area of pixels is proprotional to number of pixels assigned to it
            area = len(ind)
            if(area <= (S*S)):
                ids = [label_id-cluster.shape[1], label_id-cluster.shape[1]-1, label_id-cluster.shape[1]+1,
                       label_id-1,label_id+1,label_id+cluster.shape[1],label_id+cluster.shape[1]-1,label_id+cluster.shape[1]+1]

                u =  len(np.where(labels == ids[0])[0])  if(isValidIndex(i-1,j,cluster))   else 0
                lu = len(np.where(labels == ids[1])[0])  if(isValidIndex(i-1,j-1,cluster)) else 0
                ru = len(np.where(labels == ids[2])[0])  if(isValidIndex(i-1,j+1,cluster)) else 0
                lm = len(np.where(labels == ids[3])[0])  if(isValidIndex(i,j-1,cluster))   else 0
                rm = len(np.where(labels == ids[4])[0])  if(isValidIndex(i,j+1,cluster))   else 0
                b =  len(np.where(labels == ids[5])[0])  if(isValidIndex(i+1,j,cluster))   else 0
                lb = len(np.where(labels == ids[6])[0])  if(isValidIndex(i+1,j-1,cluster)) else 0
                rb = len(np.where(labels == ids[7])[0])  if(isValidIndex(i+1,j+1,cluster)) else 0

                assignlabel_index = np.argmax([u,lu,ru,lm,rm,b,lb,rb])
                
                ind = np.where(labels ==label_id)
                labels[ind] =  ids[assignlabel_index]

            label_id += 1


    segmap = labels.reshape(r,c)
    return segmap


#TODO diplay your SLIC results.
for k in [150]:
    clusters = SLIC(im,k)
   
    _ = rgb_segment(clusters,n = k, title =  "SLIC: Clusters: " + str(k),legend = False)
    superpixel_plot(im,clusters,title =  "SLIC: Clusters: "+ str(k))

plt.show()




"""## Bonus Question:
Enforce connectivity: There are many superpixels which are very small and disconnected from each other. Try to merge them with larger superpixels

O(N) algorithm:
1. Set a minimum size of superpixel
2. If the area of a region is smaller than a threshold, we assign it to the nearest cluster
"""




